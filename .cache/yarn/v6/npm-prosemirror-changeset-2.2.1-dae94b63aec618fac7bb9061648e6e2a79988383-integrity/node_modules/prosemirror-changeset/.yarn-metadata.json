{
  "manifest": {
    "name": "prosemirror-changeset",
    "version": "2.2.1",
    "description": "Distills a series of editing steps into deleted and added ranges",
    "type": "module",
    "main": "dist/index.cjs",
    "module": "dist/index.js",
    "types": "dist/index.d.ts",
    "exports": {
      "import": "./dist/index.js",
      "require": "./dist/index.cjs"
    },
    "sideEffects": false,
    "license": "MIT",
    "maintainers": [
      {
        "name": "Marijn Haverbeke",
        "email": "marijn@haverbeke.berlin",
        "url": "http://marijnhaverbeke.nl"
      }
    ],
    "repository": {
      "type": "git",
      "url": "git://github.com/prosemirror/prosemirror-changeset.git"
    },
    "dependencies": {
      "prosemirror-transform": "^1.0.0"
    },
    "devDependencies": {
      "@prosemirror/buildhelper": "^0.1.5",
      "prosemirror-model": "^1.0.0",
      "prosemirror-test-builder": "^1.0.0"
    },
    "scripts": {
      "test": "pm-runtests",
      "prepare": "pm-buildhelper src/changeset.ts",
      "build-readme": "FIXME"
    },
    "_registry": "npm",
    "_loc": "/home/erp/.cache/yarn/v6/npm-prosemirror-changeset-2.2.1-dae94b63aec618fac7bb9061648e6e2a79988383-integrity/node_modules/prosemirror-changeset/package.json",
    "readmeFilename": "README.md",
    "readme": "# prosemirror-changeset\n\nThis is a helper module that can turn a sequence of document changes\ninto a set of insertions and deletions, for example to display them in\na change-tracking interface. Such a set can be built up incrementally,\nin order to do such change tracking in a halfway performant way during\nlive editing.\n\nThis code is licensed under an [MIT\nlicence](https://github.com/ProseMirror/prosemirror-changeset/blob/master/LICENSE).\n\n## Programming interface\n\nInsertions and deletions are represented as ‘spans’—ranges in the\ndocument. The deleted spans refer to the original document, whereas\nthe inserted ones point into the current document.\n\nIt is possible to associate arbitrary data values with such spans, for\nexample to track the user that made the change, the timestamp at which\nit was made, or the step data necessary to invert it again.\n\n### class Change`<Data = any>`\n\nA replaced range with metadata associated with it.\n\n * **`fromA`**`: number`\\\n   The start of the range deleted/replaced in the old document.\n\n * **`toA`**`: number`\\\n   The end of the range in the old document.\n\n * **`fromB`**`: number`\\\n   The start of the range inserted in the new document.\n\n * **`toB`**`: number`\\\n   The end of the range in the new document.\n\n * **`deleted`**`: readonly Span[]`\\\n   Data associated with the deleted content. The length of these\n   spans adds up to `this.toA - this.fromA`.\n\n * **`inserted`**`: readonly Span[]`\\\n   Data associated with the inserted content. Length adds up to\n   `this.toB - this.toA`.\n\n * `static `**`merge`**`<Data>(x: readonly Change[], y: readonly Change[], combine: fn(dataA: Data, dataB: Data) → Data) → readonly Change[]`\\\n   This merges two changesets (the end document of x should be the\n   start document of y) into a single one spanning the start of x to\n   the end of y.\n\n\n### class Span`<Data = any>`\n\nStores metadata for a part of a change.\n\n * **`length`**`: number`\\\n   The length of this span.\n\n * **`data`**`: Data`\\\n   The data associated with this span.\n\n\n### class ChangeSet`<Data = any>`\n\nA change set tracks the changes to a document from a given point\nin the past. It condenses a number of step maps down to a flat\nsequence of replacements, and simplifies replacments that\npartially undo themselves by comparing their content.\n\n * **`changes`**`: readonly Change[]`\\\n   Replaced regions.\n\n * **`addSteps`**`(newDoc: Node, maps: readonly StepMap[], data: Data | readonly Data[]) → ChangeSet`\\\n   Computes a new changeset by adding the given step maps and\n   metadata (either as an array, per-map, or as a single value to be\n   associated with all maps) to the current set. Will not mutate the\n   old set.\n\n   Note that due to simplification that happens after each add,\n   incrementally adding steps might create a different final set\n   than adding all those changes at once, since different document\n   tokens might be matched during simplification depending on the\n   boundaries of the current changed ranges.\n\n * **`startDoc`**`: Node`\\\n   The starting document of the change set.\n\n * **`map`**`(f: fn(range: Span) → Data) → ChangeSet`\\\n   Map the span's data values in the given set through a function\n   and construct a new set with the resulting data.\n\n * **`changedRange`**`(b: ChangeSet, maps?: readonly StepMap[]) → {from: number, to: number}`\\\n   Compare two changesets and return the range in which they are\n   changed, if any. If the document changed between the maps, pass\n   the maps for the steps that changed it as second argument, and\n   make sure the method is called on the old set and passed the new\n   set. The returned positions will be in new document coordinates.\n\n * `static `**`create`**`<Data = any>(doc: Node, combine?: fn(dataA: Data, dataB: Data) → Data = (a, b) => a === b ? a : null as any) → ChangeSet`\\\n   Create a changeset with the given base object and configuration.\n   The `combine` function is used to compare and combine metadata—it\n   should return null when metadata isn't compatible, and a combined\n   version for a merged range when it is.\n\n\n * **`simplifyChanges`**`(changes: readonly Change[], doc: Node) → Change[]`\\\n   Simplifies a set of changes for presentation. This makes the\n   assumption that having both insertions and deletions within a word\n   is confusing, and, when such changes occur without a word boundary\n   between them, they should be expanded to cover the entire set of\n   words (in the new document) they touch. An exception is made for\n   single-character replacements.\n\n",
    "licenseText": "Copyright (C) 2017 by Marijn Haverbeke <marijn@haverbeke.berlin> and others\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/prosemirror-changeset/-/prosemirror-changeset-2.2.1.tgz#dae94b63aec618fac7bb9061648e6e2a79988383",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/prosemirror-changeset/-/prosemirror-changeset-2.2.1.tgz",
    "hash": "dae94b63aec618fac7bb9061648e6e2a79988383",
    "integrity": "sha512-J7msc6wbxB4ekDFj+n9gTW/jav/p53kdlivvuppHsrZXCaQdVgRghoZbSS3kwrRyAstRVQ4/+u5k7YfLgkkQvQ==",
    "registry": "npm",
    "packageName": "prosemirror-changeset",
    "cacheIntegrity": "sha512-J7msc6wbxB4ekDFj+n9gTW/jav/p53kdlivvuppHsrZXCaQdVgRghoZbSS3kwrRyAstRVQ4/+u5k7YfLgkkQvQ== sha1-2ulLY67GGPrHu5BhZI5uKnmYg4M="
  },
  "registry": "npm",
  "hash": "dae94b63aec618fac7bb9061648e6e2a79988383"
}